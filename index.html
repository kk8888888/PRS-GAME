<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è§†åƒåŒ–çŒœæ‹³æ¸¸æˆ | Rock Paper Scissors</title>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Outfit', sans-serif;
            font-family: 'Outfit', sans-serif;
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
            color: white;
            min-height: 100vh;
            overflow: hidden;
        }

        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        /* æ‘„åƒå¤´è§†é¢‘ */
        #camera {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            z-index: 1;
        }

        /* æ‰‹éƒ¨è¿½è¸ªç”»å¸ƒ */
        #handCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }

        /* ç²’å­æ•ˆæœç”»å¸ƒ */
        #effectCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3;
            pointer-events: none;
        }



        /* æ¸¸æˆç•Œé¢è¦†ç›–å±‚ */
        .game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
        }

        /* é¡¶éƒ¨è®¡åˆ†æ¿ */
        .scoreboard {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 40px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 40px;
            border-radius: 20px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            pointer-events: auto;
            z-index: 10;
        }

        .score-item {
            text-align: center;
        }

        .score-label {
            font-size: 14px;
            opacity: 0.8;
            margin-bottom: 5px;
        }

        .score-value {
            font-size: 32px;
            font-weight: 700;
        }

        .score-value.player {
            color: #00ff88;
        }

        .score-value.computer {
            color: #ff4466;
        }

        .score-value.points {
            color: #ffd700;
        }

        .score-value.level {
            color: #bd00ff;
        }

        /* æˆ˜æ–—åŒºåŸŸ */
        .battle-area {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            align-items: center;
            gap: 60px;
            z-index: 50;
            pointer-events: none;
        }

        .gesture-display {
            width: 180px;
            height: 180px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
            border: 3px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
        }

        .gesture-group {
            display: flex;
            gap: 20px;
        }

        .gesture-display.player {
            border-color: #00ff88;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.3);
        }

        .gesture-display.computer {
            border-color: #ff4466;
            box-shadow: 0 0 30px rgba(255, 68, 102, 0.3);
        }

        .gesture-emoji {
            font-size: 72px;
            margin-bottom: 5px;
        }

        .gesture-name {
            font-size: 18px;
            font-weight: 600;
        }

        .vs-text {
            font-size: 36px;
            font-weight: 700;
            color: #ffd700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        /* å€’è®¡æ—¶ */
        .countdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 150px;
            font-weight: 700;
            color: #ffd700;
            text-shadow: 0 0 50px rgba(255, 215, 0, 0.8);
            opacity: 0;
            animation: none;
        }

        .countdown.active {
            animation: pulse 1s ease-in-out;
        }

        @keyframes pulse {
            0% {
                transform: translate(-50%, -50%) scale(0.5);
                opacity: 0;
            }

            50% {
                transform: translate(-50%, -50%) scale(1.2);
                opacity: 1;
            }

            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0;
            }
        }

        /* ç»“æœæç¤º */
        .result-banner {
            position: absolute;
            top: 35%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            font-size: 64px;
            font-weight: 700;
            padding: 20px 60px;
            border-radius: 20px;
            transition: transform 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .result-banner.show {
            transform: translate(-50%, -50%) scale(1);
        }

        .result-banner.win {
            background: linear-gradient(135deg, #00ff88, #00cc6a);
            color: #000;
            box-shadow: 0 0 60px rgba(0, 255, 136, 0.6);
        }

        .result-banner.lose {
            background: linear-gradient(135deg, #ff4466, #cc3355);
            color: #fff;
            box-shadow: 0 0 60px rgba(255, 68, 102, 0.6);
        }

        .result-banner.draw {
            background: linear-gradient(135deg, #4488ff, #3366cc);
            color: #fff;
            box-shadow: 0 0 60px rgba(68, 136, 255, 0.6);
        }

        /* å¼€å§‹æŒ‰é’® */
        .start-btn {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            padding: 20px 60px;
            font-size: 24px;
            font-weight: 700;
            border: none;
            border-radius: 50px;
            background: linear-gradient(135deg, #ffd700, #ffaa00);
            color: #000;
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.3s ease;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            z-index: 20;
        }

        .start-btn:hover {
            transform: translateX(-50%) scale(1.1);
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.8);
        }

        .start-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: translateX(-50%);
        }

        /* æ‰‹åŠ¿æç¤º */
        .gesture-hints {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 15px;
            gap: 15px;
            pointer-events: auto;
            z-index: 20;
        }

        .hint {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: transform 0.3s ease;
        }

        .hint:hover {
            transform: translateY(-5px);
        }

        .hint-emoji {
            font-size: 36px;
        }

        .hint-name {
            font-size: 14px;
            font-weight: 600;
        }

        /* å½“å‰æ£€æµ‹æ‰‹åŠ¿ */
        .detected-gesture {
            position: absolute;
            bottom: 120px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 25px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 2px solid #00ff88;
            border: 2px solid #00ff88;
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 20;
        }

        .detected-gesture .emoji {
            font-size: 48px;
        }

        .detected-gesture .text {
            font-size: 18px;
        }

        .detected-gesture .label {
            opacity: 0.7;
            font-size: 14px;
        }

        /* å¥–åŠ±å¼¹çª— */
        .reward-popup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: linear-gradient(135deg, #ffd700, #ffaa00);
            color: #000;
            padding: 30px 50px;
            border-radius: 25px;
            text-align: center;
            z-index: 100;
            transition: transform 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .reward-popup.show {
            transform: translate(-50%, -50%) scale(1);
        }

        .reward-popup h2 {
            font-size: 32px;
            margin-bottom: 10px;
        }

        .reward-popup p {
            font-size: 48px;
            font-weight: 700;
        }

        /* è¿èƒœæŒ‡ç¤ºå™¨ */
        .streak-indicator {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #ff6b35, #f7931e);
            padding: 10px 30px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: 600;
            display: none;
        }

        .streak-indicator.show {
            display: block;
            animation: bounce 0.5s ease;
        }

        @keyframes bounce {

            0%,
            100% {
                transform: translateX(-50%) translateY(0);
            }

            50% {
                transform: translateX(-50%) translateY(-10px);
            }
        }

        /* åŠ è½½æŒ‡ç¤ºå™¨ */
        .loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .loading.hidden {
            display: none;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 5px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            border-top: 5px solid #ffd700;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .loading p {
            font-size: 18px;
            opacity: 0.8;
        }

        /* å±å¹•éœ‡åŠ¨æ•ˆæœ */
        @keyframes shake {

            0%,
            100% {
                transform: translateX(0);
            }

            10%,
            30%,
            50%,
            70%,
            90% {
                transform: translateX(-10px);
            }

            20%,
            40%,
            60%,
            80% {
                transform: translateX(10px);
            }
        }

        .shake {
            animation: shake 0.5s cubic-bezier(.36, .07, .19, .97) both;
        }

        .shake {
            animation: shake 0.5s cubic-bezier(.36, .07, .19, .97) both;
        }

        /* æ’è¡Œæ¦œ */
        .leaderboard-btn {
            position: absolute;
            top: 100px;
            right: 20px;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #ffd700;
            color: #ffd700;
            border-radius: 20px;
            cursor: pointer;
            z-index: 1000;
            transition: all 0.3s;
            font-weight: bold;
        }

        .leaderboard-btn:hover {
            background: #ffd700;
            color: #000;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
        }

        .leaderboard-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            width: 90%;
            max-width: 450px;
            background: rgba(15, 15, 25, 0.95);
            border: 2px solid #00ff88;
            border-radius: 20px;
            padding: 30px;
            z-index: 10005;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(20px);
            color: white;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
        }

        .leaderboard-panel.show {
            opacity: 1;
            visibility: visible;
            transform: translate(-50%, -50%) scale(1);
        }

        .leaderboard-title {
            font-size: 32px;
            color: #00ff88;
            text-align: center;
            margin-bottom: 25px;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
            font-weight: bold;
        }

        .rank-list {
            max-height: 450px;
            overflow-y: auto;
            margin-bottom: 25px;
            padding-right: 5px;
        }

        .rank-list::-webkit-scrollbar {
            width: 6px;
        }

        .rank-list::-webkit-scrollbar-thumb {
            background: rgba(0, 255, 136, 0.3);
            border-radius: 3px;
        }

        .rank-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            margin-bottom: 12px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.2s;
        }

        .rank-item:hover {
            transform: translateX(5px);
            background: rgba(0, 255, 136, 0.1);
            border-color: rgba(0, 255, 136, 0.3);
        }

        .rank-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .rank-pos {
            font-weight: bold;
            font-size: 22px;
            width: 40px;
            height: 40px;
            background: rgba(0, 255, 136, 0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #00ff88;
        }

        .rank-score-details {
            display: flex;
            flex-direction: column;
        }

        .rank-score {
            color: #ffd700;
            font-size: 22px;
            font-weight: bold;
        }

        .rank-date {
            color: #888;
            font-size: 12px;
            margin-top: 4px;
        }

        .close-btn {
            display: block;
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #ff4466, #ff2244);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-weight: bold;
            font-size: 18px;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(255, 68, 102, 0.3);
        }

        .close-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(255, 68, 102, 0.4);
        }

        /* å±å¹•é—ªå…‰ */
        @keyframes flash {
            0% {
                background-color: rgba(255, 255, 255, 0.8);
            }

            100% {
                background-color: transparent;
            }
        }

        .flash-effect {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 200;
            animation: flash 0.3s ease-out;
        }

        /* é€Ÿåº¦æ¨¡å¼ */
        .speed-mode {
            animation: container-glow 2s infinite alternate;
        }

        @keyframes container-glow {
            from {
                box-shadow: inset 0 0 50px rgba(255, 0, 0, 0.1);
            }

            to {
                box-shadow: inset 0 0 150px rgba(255, 215, 0, 0.3);
            }
        }

        .speed-mode #battleArea {
            filter: drop-shadow(0 0 20px #ffd700);
        }

        /* å€’è®¡æ—¶å¿ƒè·³ */
        @keyframes heartbeat {
            0% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.8;
            }

            15% {
                transform: translate(-50%, -50%) scale(1.3);
                opacity: 1;
            }

            30% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.8;
            }

            45% {
                transform: translate(-50%, -50%) scale(1.15);
                opacity: 1;
            }

            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0;
            }
        }

        .countdown.heartbeat {
            animation: heartbeat 0.8s ease-in-out;
            color: #ff4466;
            /* çº¢è‰²å¿ƒè·³ */
            text-shadow: 0 0 50px rgba(255, 68, 102, 0.8);
        }

        /* ç´§å¼ é®ç½© */
        .tension-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 20%, rgba(0, 0, 0, 0.8) 90%);
            z-index: 5;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }

        .tension-overlay.active {
            opacity: 1;
        }
    </style>
</head>

<body>
    <div class="container" id="container">
        <!-- æ‘„åƒå¤´è§†é¢‘ -->
        <!-- æ‘„åƒå¤´è§†é¢‘ -->
        <video id="camera" autoplay playsinline></video>

        <!-- æ‰‹éƒ¨è¿½è¸ªç”»å¸ƒ -->
        <canvas id="handCanvas"></canvas>

        <!-- ç²’å­æ•ˆæœç”»å¸ƒ -->
        <canvas id="effectCanvas"></canvas>

        <!-- ç´§å¼ é®ç½© (Suspense Overlay) -->
        <div class="tension-overlay" id="tensionOverlay"></div>

        <!-- è®¡åˆ†æ¿ -->
        <div class="scoreboard">
            <div class="score-item">
                <div class="score-label">ä½ </div>
                <div class="score-value player" id="playerScore">0</div>
            </div>
            <div class="score-item">
                <div class="score-label">ç§¯åˆ†</div>
                <div class="score-value points" id="totalPoints">0</div>
            </div>
            <div class="score-item">
                <div class="score-label">ç”µè„‘</div>
                <div class="score-value computer" id="computerScore">0</div>
            </div>
            <div class="score-item">
                <div class="score-label">éš¾åº¦</div>
                <div class="score-value level" id="levelDisplay">1</div>
            </div>
        </div>

        <!-- æ’è¡Œæ¦œæŒ‰é’® -->
        <div class="leaderboard-btn" id="openLeaderboard">ğŸ† æ’è¡Œæ¦œ</div>

        <!-- æ’è¡Œæ¦œé¢æ¿ -->
        <div class="leaderboard-panel" id="leaderboardPanel">
            <div class="leaderboard-title">ğŸ† è£èª‰æ®¿å ‚</div>
            <div class="rank-list" id="rankList">
                <!-- åŠ¨æ€ç”Ÿæˆ -->
                <div style="text-align:center; padding: 20px; color: #888;">æš‚æ— è®°å½•</div>
            </div>
            <button class="close-btn" id="closeLeaderboard">ç¡®è®¤</button>
        </div>

        <!-- è¿èƒœæŒ‡ç¤ºå™¨ -->
        <div class="streak-indicator" id="streakIndicator">ğŸ”¥ è¿èƒœ <span id="streakCount">0</span> å±€!</div>

        <!-- æˆ˜æ–—åŒºåŸŸ -->
        <div class="battle-area" id="battleArea" style="display: none;">
            <div class="gesture-group" id="playerGesturesArea">
                <div class="gesture-display player">
                    <div class="gesture-emoji" id="playerGestureEmoji">â“</div>
                    <div class="gesture-name" id="playerGestureName">ç­‰å¾…...</div>
                </div>
            </div>
            <div class="vs-text">VS</div>
            <div class="gesture-group" id="computerGesturesArea">
                <div class="gesture-display computer">
                    <div class="gesture-emoji" id="computerGestureEmoji">â“</div>
                    <div class="gesture-name" id="computerGestureName">ç­‰å¾…...</div>
                </div>
            </div>
        </div>

        <!-- å€’è®¡æ—¶ -->
        <div class="countdown" id="countdown">3</div>

        <!-- ç»“æœæç¤º -->
        <div class="result-banner" id="resultBanner"></div>

        <!-- å¼€å§‹æŒ‰é’® -->
        <button class="start-btn" id="startBtn">ğŸ® å¼€å§‹æ¸¸æˆ</button>

        <!-- å½“å‰æ£€æµ‹æ‰‹åŠ¿ -->
        <div class="detected-gesture" id="detectedGesture">
            <div class="emoji" id="detectedEmoji">âœ‹</div>
            <div>
                <div class="label">æ£€æµ‹åˆ°çš„æ‰‹åŠ¿</div>
                <div class="text" id="detectedName">æ— </div>
            </div>
        </div>

        <!-- æ‰‹åŠ¿æç¤º -->
        <div class="gesture-hints">
            <div class="hint">
                <div class="hint-emoji">âœŠ</div>
                <div class="hint-name">çŸ³å¤´</div>
            </div>
            <div class="hint">
                <div class="hint-emoji">âœŒï¸</div>
                <div class="hint-name">å‰ªåˆ€</div>
            </div>
            <div class="hint">
                <div class="hint-emoji">ğŸ–ï¸</div>
                <div class="hint-name">å¸ƒ</div>
            </div>
        </div>

        <!-- å¥–åŠ±å¼¹çª— -->
        <div class="reward-popup" id="rewardPopup">
            <h2>ğŸ‰ å¥–åŠ±!</h2>
            <p id="rewardPoints">+50</p>
        </div>
    </div>

    <!-- åŠ è½½æŒ‡ç¤ºå™¨ -->
    <div class="loading" id="loading">
        <div class="spinner"></div>
        <p>æ­£åœ¨åŠ è½½æ‘„åƒå¤´å’Œæ‰‹åŠ¿è¯†åˆ«...</p>
    </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.min.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/face_mesh.min.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675466862/camera_utils.min.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1675466124/drawing_utils.min.js"
        crossorigin="anonymous"></script>


    <script>
        // DOMå…ƒç´ 
        const cameraElement = document.getElementById('camera');
        const handCanvas = document.getElementById('handCanvas');
        const effectCanvas = document.getElementById('effectCanvas');

        const handCtx = handCanvas.getContext('2d');
        const effectCtx = effectCanvas.getContext('2d');
        const loadingElement = document.getElementById('loading');
        const startBtn = document.getElementById('startBtn');
        const countdownElement = document.getElementById('countdown');
        const battleArea = document.getElementById('battleArea');
        const resultBanner = document.getElementById('resultBanner');
        const streakIndicator = document.getElementById('streakIndicator');
        const rewardPopup = document.getElementById('rewardPopup');
        const containerElement = document.getElementById('container');

        // æ¸¸æˆçŠ¶æ€
        let gameState = 'idle'; // idle, countdown, playing, result
        let playerScore = 0;
        let computerScore = 0;
        let totalPoints = 0;
        let currentStreak = 0; // Win streak
        let loseStreak = 0; // Lose streak
        let currentLevel = 1;
        let detectedGesture = 'none';
        let detectedGestures = []; // Array of gestures for multi-hand
        let particles = [];
        let faceResults = null; // Store face mesh results for mask drawing
        let faceEffect = 'normal'; // normal, glow, sweat, red, cyan, car
        let rainParticles = [];
        let isRainy = false;
        let thunderIntensity = 0;
        let darkness = 0; // 0 to 1
        let isGameOver = false;


        // æ‰‹åŠ¿æ˜ å°„
        const gestureMap = {
            rock: { emoji: 'âœŠ', name: 'çŸ³å¤´', cn: 'çŸ³å¤´' },
            scissors: { emoji: 'âœŒï¸', name: 'å‰ªåˆ€', cn: 'å‰ªåˆ€' },
            paper: { emoji: 'ğŸ–ï¸', name: 'å¸ƒ', cn: 'å¸ƒ' },
            none: { emoji: 'â“', name: 'æ— ', cn: 'æ— ' }
        };

        // å£°éŸ³ç®¡ç†å™¨
        class SoundManager {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.3; // é»˜è®¤éŸ³é‡
                this.masterGain.connect(this.ctx.destination);
                this.enabled = true;

                // Rhythm state
                this.bpm = 100;
                this.nextNoteTime = 0;
                this.timerID = null;
                this.isPlayingRhythm = false;
            }

            // --- Drum Synthesis ---
            playKick(time) {
                if (!this.enabled) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.frequency.setValueAtTime(150, time);
                osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
                gain.gain.setValueAtTime(0.5, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start(time);
                osc.stop(time + 0.5);
            }

            playSnare(time) {
                if (!this.enabled) return;
                const noise = this.ctx.createBufferSource();
                const bufferSize = this.ctx.sampleRate * 0.1;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                noise.buffer = buffer;

                const noiseFilter = this.ctx.createBiquadFilter();
                noiseFilter.type = 'highpass';
                noiseFilter.frequency.value = 1000;
                noise.connect(noiseFilter);

                const noiseGain = this.ctx.createGain();
                noiseGain.gain.setValueAtTime(0.3, time);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, time + 0.1);
                noiseFilter.connect(noiseGain);
                noiseGain.connect(this.masterGain);

                noise.start(time);
                noise.stop(time + 0.1);
            }

            // --- Rhythm Engine ---
            startRhythm() {
                if (this.isPlayingRhythm) return;
                this.isPlayingRhythm = true;
                this.nextNoteTime = this.ctx.currentTime;
                this.scheduler();
            }

            stopRhythm() {
                this.isPlayingRhythm = false;
                clearTimeout(this.timerID);
            }

            updateBpm(score) {
                // Base 110, goes up to 220 as score reaches 500
                this.bpm = Math.min(220, 110 + (score / 5));
            }

            scheduler() {
                while (this.nextNoteTime < this.ctx.currentTime + 0.1) {
                    this.scheduleNextNote(this.nextNoteTime);
                    this.nextNoteTime += 60.0 / this.bpm / 2; // 8th notes
                }
                if (this.isPlayingRhythm) {
                    this.timerID = setTimeout(() => this.scheduler(), 25);
                }
            }

            scheduleNextNote(time) {
                const beat = Math.floor(time * (this.bpm / 60) * 2) % 8;
                if (beat === 0 || beat === 4) this.playKick(time);
                if (beat === 2 || beat === 6) this.playSnare(time);
            }

            // æ’­æ”¾æŒ¯è¡å™¨å£°éŸ³
            playTone(freq, type, duration, startTime = 0) {
                if (!this.enabled) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime + startTime);

                gain.gain.setValueAtTime(0.5, this.ctx.currentTime + startTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + startTime + duration);

                osc.connect(gain);
                gain.connect(this.masterGain);

                osc.start(this.ctx.currentTime + startTime);
                osc.stop(this.ctx.currentTime + startTime + duration);
            }

            playCountdown() {
                // Revert to classic beep
                this.playTone(800, 'sine', 0.1);
            }

            playTension() {
                // Remove tension sound or make very subtle
            }

            playStart() {
                // çˆ†å‘å£°
                this.playTone(1200, 'square', 0.1);
                this.playTone(800, 'sawtooth', 0.3);
            }

            playWin() {
                const now = 0;
                this.playTone(523.25, 'triangle', 0.2, now);       // C5
                this.playTone(659.25, 'triangle', 0.2, now + 0.1); // E5
                this.playTone(783.99, 'triangle', 0.4, now + 0.2); // G5
                this.playTone(1046.50, 'triangle', 0.6, now + 0.3); // C6
            }

            playLose() {
                const now = 0;
                this.playTone(392.00, 'sawtooth', 0.3, now);       // G4
                this.playTone(369.99, 'sawtooth', 0.3, now + 0.2); // F#4
                this.playTone(349.23, 'sawtooth', 0.3, now + 0.4); // F4
                this.playTone(200.00, 'sawtooth', 0.8, now + 0.6); // Low
            }

            playDraw() {
                this.playTone(440, 'sine', 0.1, 0);
                this.playTone(440, 'sine', 0.1, 0.15);
            }

            resume() {
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            }
        }

        const soundManager = new SoundManager();

        // ç²’å­ç±» - å‡çº§ç‰ˆ
        class Particle {
            constructor(x, y, color, type = 'circle') { // type: circle, square, triangle
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 15;
                this.vy = (Math.random() - 0.5) * 15 - 5;
                this.life = 60 + Math.random() * 40;
                this.maxLife = this.life;
                this.color = color;
                this.size = Math.random() * 8 + 4;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.2;
                this.type = type;

                // ç‰©ç†ç‰¹æ€§
                if (type === 'square') { // çŸ³å¤´: é‡åŠ›å¤§
                    this.gravity = 0.4;
                    this.drag = 0.95;
                } else if (type === 'triangle') { // å‰ªåˆ€: é€Ÿåº¦å¿«
                    this.gravity = 0.2;
                    this.drag = 0.98;
                    this.vx *= 1.5;
                    this.vy *= 1.5;
                } else { // å¸ƒ: æ¼‚æµ®
                    this.gravity = 0.1;
                    this.drag = 0.94;
                    this.vx *= 0.8;
                }
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += this.gravity;
                this.rotation += this.rotationSpeed;
                this.life--;
                this.vx *= this.drag;
                this.vy *= this.drag;
            }

            draw(ctx) {
                if (this.life <= 0) return;
                const alpha = this.life / this.maxLife;
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);

                ctx.fillStyle = this.color;

                if (this.type === 'square') {
                    ctx.fillRect(-this.size, -this.size, this.size * 2, this.size * 2);
                } else if (this.type === 'triangle') {
                    ctx.beginPath();
                    ctx.moveTo(0, -this.size);
                    ctx.lineTo(this.size, this.size);
                    ctx.lineTo(-this.size, this.size);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }

            isAlive() {
                return this.life > 0;
            }
        }

        // åˆ›å»ºèƒœåˆ©ç²’å­æ•ˆæœ
        function createWinParticles(gesture) {
            const centerX = effectCanvas.width / 2;
            const centerY = effectCanvas.height / 2;

            let colors, type;
            if (gesture === 'rock') {
                colors = ['#ff6b35', '#f7931e', '#808080'];
                type = 'square';
            } else if (gesture === 'scissors') {
                colors = ['#ff4466', '#ffcc00', '#ffffff'];
                type = 'triangle';
            } else { // paper
                colors = ['#00ff88', '#00cc6a', '#4488ff'];
                type = 'circle';
            }

            for (let i = 0; i < 150; i++) {
                const color = colors[Math.floor(Math.random() * colors.length)];
                particles.push(new Particle(centerX, centerY, color, type));
            }
        }

        // åˆ›å»ºå¤±è´¥æ•ˆæœ
        function createLoseEffect() {
            containerElement.classList.add('shake');
            setTimeout(() => containerElement.classList.remove('shake'), 300);
        }

        // åˆ›å»ºå¹³å±€æ•ˆæœ
        function createDrawParticles() {
            const centerX = effectCanvas.width / 2;
            const centerY = effectCanvas.height / 2;
            const colors = ['#4488ff', '#3366cc', '#88aaff'];

            for (let i = 0; i < 50; i++) {
                const angle = (i / 50) * Math.PI * 2;
                const x = centerX + Math.cos(angle) * 100;
                const y = centerY + Math.sin(angle) * 100;
                const color = colors[Math.floor(Math.random() * colors.length)];
                particles.push(new Particle(x, y, color, 'circle'));
            }
        }

        // æ›´æ–°ç²’å­
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                if (!particles[i].isAlive()) {
                    particles.splice(i, 1);
                }
            }
        }

        // ç»˜åˆ¶ç²’å­
        function drawParticles() {
            effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);
            particles.forEach(p => p.draw(effectCtx));
        }

        // è¯†åˆ«æ‰‹åŠ¿
        function recognizeGesture(landmarks) {
            if (!landmarks) return 'none';

            // æ‰‹æŒ‡å…³é”®ç‚¹
            const thumbTip = landmarks[4];
            const thumbIP = landmarks[3];
            const indexTip = landmarks[8];
            const indexPIP = landmarks[6];
            const middleTip = landmarks[12];
            const middlePIP = landmarks[10];
            const ringTip = landmarks[16];
            const ringPIP = landmarks[14];
            const pinkyTip = landmarks[20];
            const pinkyPIP = landmarks[18];
            const wrist = landmarks[0];

            // æ£€æµ‹æ‰‹æŒ‡æ˜¯å¦ä¼¸ç›´
            const isIndexExtended = indexTip.y < indexPIP.y;
            const isMiddleExtended = middleTip.y < middlePIP.y;
            const isRingExtended = ringTip.y < ringPIP.y;
            const isPinkyExtended = pinkyTip.y < pinkyPIP.y;

            // æ‹‡æŒ‡æ£€æµ‹ (æ°´å¹³æ–¹å‘)
            const isThumbExtended = Math.abs(thumbTip.x - wrist.x) > Math.abs(thumbIP.x - wrist.x);

            // è®¡ç®—ä¼¸ç›´æ‰‹æŒ‡æ•°é‡
            const extendedCount = [isIndexExtended, isMiddleExtended, isRingExtended, isPinkyExtended]
                .filter(Boolean).length;

            // çŸ³å¤´: æ‰€æœ‰æ‰‹æŒ‡å¼¯æ›² (æ¡æ‹³)
            if (extendedCount === 0 && !isThumbExtended) {
                return 'rock';
            }

            // èµ/é‡å¼€: æ‹‡æŒ‡ä¼¸ç›´ (yæ¯”ipé«˜) ä¸” å…¶ä»–æ‰‹æŒ‡å¼¯æ›² (æˆ–è€…ç®€å•åˆ¤æ–­æ‹‡æŒ‡å‘ä¸Š)
            // ç®€åŒ–ç‰ˆèµ: æ‹‡æŒ‡æŒ‡å°– < æ‹‡æŒ‡å…³èŠ‚ (Yè½´å‘ä¸Š) ä¸” é£ŸæŒ‡æŒ‡å°– > é£ŸæŒ‡å…³èŠ‚ (Yè½´å‘ä¸‹/å¼¯æ›²)
            if (thumbTip.y < thumbIP.y && indexTip.y > indexPIP.y) {
                return 'thumbs_up';
            }

            // åŸæ¥çš„æ°´å¹³èµæ£€æµ‹å¤‡ç”¨
            if (extendedCount === 0 && isThumbExtended) {
                return 'thumbs_up';
            }

            // å‰ªåˆ€: åªæœ‰é£ŸæŒ‡å’Œä¸­æŒ‡ä¼¸ç›´
            if (isIndexExtended && isMiddleExtended && !isRingExtended && !isPinkyExtended) {
                return 'scissors';
            }

            // å¸ƒ: æ‰€æœ‰æ‰‹æŒ‡ä¼¸ç›´
            if (extendedCount >= 4) {
                return 'paper';
            }

            // å¦ä¸€ç§çŸ³å¤´æ£€æµ‹: æ‰‹æŒ‡éƒ½å¼¯æ›²
            if (extendedCount <= 1 && !isThumbExtended) {
                return 'rock';
            }

            return 'none';
        }

        // åˆ¤å®šèƒœè´Ÿ
        function determineWinner(player, computer) {
            if (player === computer) return 'draw';
            if (
                (player === 'rock' && computer === 'scissors') ||
                (player === 'scissors' && computer === 'paper') ||
                (player === 'paper' && computer === 'rock')
            ) {
                return 'win';
            }
            return 'lose';
        }

        // ç”µè„‘å‡ºæ‹³
        function getComputerChoice() {
            const choices = ['rock', 'scissors', 'paper'];
            return choices[Math.floor(Math.random() * choices.length)];
        }

        // åˆ¤å®šå•æ‰‹èƒœè´Ÿ
        function getSingleResult(p, c) {
            if (p === c) return 'draw';
            if ((p === 'rock' && c === 'scissors') ||
                (p === 'scissors' && c === 'paper') ||
                (p === 'paper' && c === 'rock')) return 'win';
            return 'lose';
        }

        // æ›´æ–°æˆ˜æ–—åŒºåŸŸUI
        function updateBattleUI(level) {
            const playerArea = document.getElementById('playerGesturesArea');
            const computerArea = document.getElementById('computerGesturesArea');
            const count = level >= 2 ? 2 : 1;

            // æ£€æŸ¥æ˜¯å¦éœ€è¦é‡å»º: æ•°é‡ä¸ç¬¦ OR IDç¼ºå¤± (ä¿®å¤åˆå§‹HTMLæ— IDçš„é—®é¢˜)
            const firstP = playerArea.firstElementChild;
            const needsBuild = playerArea.children.length !== count || (firstP && !firstP.id);

            if (needsBuild) {
                playerArea.innerHTML = '';
                computerArea.innerHTML = '';
                for (let i = 0; i < count; i++) {
                    playerArea.innerHTML += `
                        <div class="gesture-display player" id="p_gesture_${i}">
                            <div class="gesture-emoji">â“</div>
                            <div class="gesture-name">ç­‰å¾…...</div>
                        </div>`;
                    computerArea.innerHTML += `
                        <div class="gesture-display computer" id="c_gesture_${i}">
                            <div class="gesture-emoji">â“</div>
                            <div class="gesture-name">ç­‰å¾…...</div>
                        </div>`;
                }
            }
        }

        // ------------------ åŠ¨æ€èƒŒæ™¯ ------------------


        // ------------------ é¢éƒ¨ AR ------------------


        // æ˜¾ç¤ºç»“æœ
        function showResult(result, playerChoice) { // æ·»åŠ  playerChoice å‚æ•°
            resultBanner.className = 'result-banner show ' + result;

            if (result === 'win') {
                resultBanner.textContent = 'ğŸ‰ ä½ èµ¢äº†!';
                soundManager.playWin();
                createWinParticles(playerChoice); // ä¼ å…¥ç©å®¶æ‰‹åŠ¿
            } else if (result === 'lose') {
                resultBanner.textContent = 'ğŸ˜¢ ä½ è¾“äº†';
                soundManager.playLose();
                createLoseEffect();
            } else {
                resultBanner.textContent = 'ğŸ¤ å¹³å±€';
                soundManager.playDraw();
                createDrawParticles();
            }

            // Dynamic duration for result banner (faster as score increases)
            const bannerDuration = Math.max(800, 2000 - (totalPoints * 2));
            setTimeout(() => {
                resultBanner.classList.remove('show');
            }, bannerDuration);
        }

        // æ˜¾ç¤ºå¥–åŠ±
        function showReward(points, message = null) {
            const rewardPoints = document.getElementById('rewardPoints');
            rewardPoints.textContent = message || `+${points}`;
            rewardPopup.classList.add('show');

            setTimeout(() => {
                rewardPopup.classList.remove('show');
            }, 1500);
        }

        // æ›´æ–°è¿èƒœæ˜¾ç¤º
        function updateStreak() {
            const streakCount = document.getElementById('streakCount');
            streakCount.textContent = currentStreak;

            if (currentStreak >= 2) {
                streakIndicator.classList.add('show');
            } else {
                streakIndicator.classList.remove('show');
            }
        }

        // æ›´æ–°åˆ†æ•°æ˜¾ç¤º
        function updateScoreDisplay() {
            document.getElementById('playerScore').textContent = playerScore;
            document.getElementById('computerScore').textContent = computerScore;
            document.getElementById('totalPoints').textContent = totalPoints;
        }

        // è®¡ç®—å¹¶ç»™äºˆå¥–åŠ±
        function giveReward(result) {
            let points = 0;
            let showBonus = false;
            let bonusMessage = '';

            if (result === 'win') {
                points = 10; // åŸºç¡€èƒœåˆ©åˆ†æ•°
                playerScore++;
                currentStreak++;
                loseStreak = 0; // Reset lose streak

                // Reset environmental effects on win
                isRainy = false;
                thunderIntensity = 0;
                darkness = 0;

                // è¿èƒœæ•ˆæœ
                if (currentStreak >= 5) {
                    faceEffect = 'car';
                    if (currentLevel === 1) {
                        currentLevel = 2; // å‡çº§åˆ°åŒæ‰‹!
                        points += 200;
                        showBonus = true;
                        bonusMessage = 'ğŸï¸ è¿èƒœ5å±€! å‡çº§åŒæ‰‹æ¨¡å¼!';
                        soundManager.playStart();
                    } else {
                        points += 100 * currentLevel;
                        showBonus = true;
                        bonusMessage = 'ğŸï¸ è¿èƒœ5å±€! è·‘è½¦å‡ºåœº!';
                    }
                } else if (currentStreak >= 3) {
                    faceEffect = 'glow';
                    points += 50;
                    showBonus = true;
                    bonusMessage = 'âœ¨ è¿èƒœ3å±€! å‘å…‰!';
                } else {
                    faceEffect = 'normal';
                }
            } else if (result === 'lose') {
                computerScore++;
                loseStreak++;
                currentStreak = 0; // Reset win streak

                // Environmental effects based on lose streak
                if (loseStreak >= 3) isRainy = true;
                if (loseStreak >= 5) thunderIntensity = 1;
                if (loseStreak >= 7) {
                    darkness = 1;
                    isGameOver = true;
                    soundManager.stopRhythm();
                    checkGameOver();
                }

                // è¿è´¥æ•ˆæœ
                if (loseStreak >= 5) {
                    faceEffect = 'cyan';
                } else if (loseStreak >= 3) {
                    faceEffect = 'red';
                } else if (loseStreak >= 2) {
                    faceEffect = 'sweat';
                } else {
                    faceEffect = 'normal';
                }
            } else {
                // å¹³å±€ - ä¸é‡ç½®è¿èƒœ/è¿è´¥
                faceEffect = 'normal';
            }

            totalPoints += points;
            updateStreak();
            updateScoreDisplay();
            soundManager.updateBpm(totalPoints);

            // Speed Aura effect on container
            if (totalPoints > 200) {
                containerElement.classList.add('speed-mode');
            } else {
                containerElement.classList.remove('speed-mode');
            }

            // æ›´æ–°ç­‰çº§æ˜¾ç¤º
            document.getElementById('levelDisplay').textContent = currentLevel;

            if (showBonus) {
                setTimeout(() => showReward(points, bonusMessage), 500);
            }
        }

        // å¼€å§‹æ¸¸æˆå›åˆ
        async function startRound() {
            debugLog(`Attempting to start round. Current State: ${gameState}`);
            if (gameState !== 'idle') {
                debugLog("Ignored: Game not idle.");
                return;
            }

            try {
                gameState = 'countdown';
                startBtn.disabled = true;
                startBtn.innerHTML = "â³ å‡†å¤‡...";
                battleArea.style.display = 'flex';

                // å‡†å¤‡ UI
                debugLog("Updating Battle UI...");
                updateBattleUI(currentLevel);
                const numHands = currentLevel >= 2 ? 2 : 1;

                // å€’è®¡æ—¶ (æ”¹ä¸ºå¿ƒè·³é£æ ¼)
                debugLog("Starting Countdown...");

                // Safe Audio Resume
                try {
                    soundManager.resume();
                    debugLog("Audio Resumed.");
                } catch (audioErr) {
                    debugLog("Audio warning: " + audioErr.message);
                }

                // Calculate dynamic speed (faster as score increases)
                // Base delay 800ms, decreases as points increase (min 300ms)
                const countdownSpeed = Math.max(300, 800 - (totalPoints / 2));
                // Base suspense 1000ms, decreases (min 400ms)
                const suspenseSpeed = Math.max(400, 1000 - (totalPoints / 1.5));

                for (let i = 3; i >= 1; i--) {
                    countdownElement.textContent = i;
                    soundManager.playCountdown();
                    countdownElement.className = 'countdown heartbeat'; // Reset class
                    void countdownElement.offsetWidth; // è§¦å‘é‡ç»˜
                    await new Promise(r => setTimeout(r, countdownSpeed));
                }

                // æ˜¾ç¤º"å‡ºæ‹³!"
                countdownElement.textContent = 'å‡ºæ‹³!';

                // æ•æ‰å½“å‰æ‰‹åŠ¿
                gameState = 'playing';

                // è·å–ç©å®¶æ‰‹åŠ¿
                let playerChoices = [];
                for (let i = 0; i < numHands; i++) {
                    let gesture = detectedGestures[i];
                    // å¦‚æœæ˜¯Noneæˆ–ThumbsUpéƒ½è§†ä¸ºRock(é»˜è®¤),æˆ–è€…è§†ä¸ºç©º
                    if (!gesture || gesture === 'thumbs_up' || gesture === 'none') gesture = 'rock';
                    playerChoices.push(gesture);
                }

                const computerChoices = [];
                for (let i = 0; i < numHands; i++) computerChoices.push(getComputerChoice());

                // ç´§å¼ æ—¶åˆ» (Suspense)
                document.getElementById('tensionOverlay').classList.add('active');
                soundManager.playTension();
                countdownElement.style.opacity = '0'; // éšè—"å‡ºæ‹³"å­—æ ·ï¼Œä¸“æ³¨æ‰‹åŠ¿

                // Start rhythmic beat if not already
                soundManager.startRhythm();
                soundManager.updateBpm(totalPoints);

                // çŸ­æš‚å»¶è¿Ÿ (æ‚¬å¿µ)
                await new Promise(r => setTimeout(r, suspenseSpeed));

                // æ­æ™“æ—¶åˆ»!
                document.getElementById('tensionOverlay').classList.remove('active');
                countdownElement.style.opacity = '1';
                countdownElement.classList.remove('active'); // æ¸…ç†
                countdownElement.textContent = ''; // æ¸…ç©º

                // å±å¹•é—ªå…‰
                const flash = document.createElement('div');
                flash.className = 'flash-effect';
                document.body.appendChild(flash);
                setTimeout(() => flash.remove(), 500);

                soundManager.playStart(); // å†²å‡»éŸ³æ•ˆ



                // æ›´æ–°æ˜¾ç¤º
                debugLog(`Updating display: Player=${playerChoices}, Computer=${computerChoices}`);
                for (let i = 0; i < numHands; i++) {
                    const pg = gestureMap[playerChoices[i]];
                    const cg = gestureMap[computerChoices[i]];

                    const pEl = document.getElementById(`p_gesture_${i}`);
                    const cEl = document.getElementById(`c_gesture_${i}`);

                    debugLog(`Element check: pEl=${!!pEl}, cEl=${!!cEl}`);

                    if (pEl) {
                        pEl.querySelector('.gesture-emoji').textContent = pg.emoji;
                        pEl.querySelector('.gesture-name').textContent = pg.cn;
                    } else {
                        debugLog("ERROR: Player gesture element not found!");
                    }
                    if (cEl) {
                        cEl.querySelector('.gesture-emoji').textContent = cg.emoji;
                        cEl.querySelector('.gesture-name').textContent = cg.cn;
                        debugLog(`Computer shows: ${cg.emoji} ${cg.cn}`);
                    } else {
                        debugLog("ERROR: Computer gesture element not found!");
                    }
                }

                // åˆ¤å®šèƒœè´Ÿ (ç»¼åˆ)
                let wins = 0;
                let loses = 0;
                for (let i = 0; i < numHands; i++) {
                    const r = getSingleResult(playerChoices[i], computerChoices[i]);
                    if (r === 'win') wins++;
                    if (r === 'lose') loses++;
                }

                let result = 'draw';
                if (wins > loses) result = 'win';
                else if (loses > wins) result = 'lose';
                // å¹³å±€ stays draw

                if (result === 'win') {
                    playerScore++;
                } else if (result === 'lose') {
                    computerScore++;
                }

                // æ˜¾ç¤ºç»“æœå’Œå¥–åŠ±
                gameState = 'result';
                showResult(result, playerChoices[0]); // ä¼ é€’ä¸»æ‰‹åŠ¿ç”¨äºç²’å­
                giveReward(result);

                // é‡ç½®æ¸¸æˆçŠ¶æ€
                await new Promise(r => setTimeout(r, 2500));
                gameState = 'idle';
                startBtn.disabled = false;

                // éšè—æˆ˜æ–—åŒºåŸŸï¼Œæ˜¾ç¤ºæç¤º
                battleArea.style.display = 'none';
                document.getElementById('detectedName').innerHTML = 'è¯·æ¯”èµ <span style="font-size:24px">ğŸ‘</span>';
            } catch (err) {
                console.error("FATAL ERROR IN ROUND:", err);
                debugLog("ROUND ERROR: " + err.message);
                gameState = 'idle';
                startBtn.disabled = false;
                startBtn.innerHTML = "ğŸ® é‡è¯•";
                alert("æ¸¸æˆå‘ç”Ÿé”™è¯¯: " + err.message);
            }
        }

        // å¤„ç†æ‰‹éƒ¨è¯†åˆ«ç»“æœ
        function processHandResults(results) {
            // è°ƒæ•´ç”»å¸ƒå¤§å°
            handCanvas.width = cameraElement.videoWidth;
            handCanvas.height = cameraElement.videoHeight;
            effectCanvas.width = cameraElement.videoWidth;
            effectCanvas.height = cameraElement.videoHeight;

            // æ¸…é™¤ç”»å¸ƒ
            handCtx.clearRect(0, 0, handCanvas.width, handCanvas.height);
            handCtx.save();
            handCtx.scale(-1, 1);
            handCtx.translate(-handCanvas.width, 0);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                // Reset counter on detection
                if (emptyHandCount > 0) {
                    debugLog(`Hand Detected! (After ${emptyHandCount} empty frames)`);
                    emptyHandCount = 0;
                }

                detectedGestures = [];
                for (const landmarks of results.multiHandLandmarks) {
                    // ç»˜åˆ¶æ‰‹éƒ¨éª¨æ¶
                    drawConnectors(handCtx, landmarks, HAND_CONNECTIONS, {
                        color: '#00ff88',
                        lineWidth: 3
                    });
                    drawLandmarks(handCtx, landmarks, {
                        color: '#ffd700',
                        lineWidth: 2,
                        radius: 5
                    });

                    // è¯†åˆ«æ‰‹åŠ¿
                    detectedGestures.push(recognizeGesture(landmarks));
                }

                // ä¸»è¦æ‰‹åŠ¿ (ç¬¬ä¸€ä¸ªæ£€æµ‹åˆ°çš„)
                detectedGesture = detectedGestures[0];

                // æ›´æ–°æ£€æµ‹æ˜¾ç¤º (å¦‚æœæœ‰å¤šä¸ªæ‰‹åŠ¿ï¼Œæ˜¾ç¤ºç¬¬ä¸€ä¸ªénoneçš„ï¼Œæˆ–è€…ç»„åˆ)
                // æš‚æ—¶åªæ˜¾ç¤ºä¸»è¦æ‰‹åŠ¿
                const gesture = gestureMap[detectedGesture] || { emoji: 'ğŸ‘', name: 'é‡å¼€', cn: 'é‡å¼€' };
                document.getElementById('detectedEmoji').textContent = gesture.emoji;
                document.getElementById('detectedName').textContent = gesture.cn;

                // æ£€æµ‹æ˜¯å¦ä¸ºé‡å¼€æ‰‹åŠ¿
                // æ”¾å®½æ¡ä»¶: åªè¦æ£€æµ‹åˆ° thumb_up å³å¯
                const isThumbsUp = detectedGestures.includes('thumbs_up');
                if (isThumbsUp && gameState === 'idle') {
                    // æ·»åŠ è§†è§‰åé¦ˆ
                    const detectedNameEl = document.getElementById('detectedName');
                    if (!window.thumbsUpTimer) {
                        detectedNameEl.innerHTML = 'å³å°†å¼€å§‹... <span style="color:#00ff88">3</span>';
                        let count = 3;

                        window.thumbsUpTimer = setInterval(() => {
                            count--;
                            if (count > 0) {
                                detectedNameEl.innerHTML = `å³å°†å¼€å§‹... <span style="color:#00ff88">${count}</span>`;
                            } else {
                                clearInterval(window.thumbsUpTimer);
                                window.thumbsUpTimer = null;
                                startRound();
                            }
                        }, 500); // 0.5ç§’ä¸€è·³ï¼Œå…±1.5ç§’
                    }
                } else {
                    if (window.thumbsUpTimer && !isThumbsUp) {
                        clearInterval(window.thumbsUpTimer);
                        window.thumbsUpTimer = null;
                        document.getElementById('detectedName').innerHTML = 'è¯·æ¯”èµ <span style="font-size:24px">ğŸ‘</span>';
                    }
                }

            } else {
                emptyHandCount++;
                if (emptyHandCount % 100 === 0) {
                    debugLog(`No Hand Detected (${emptyHandCount} frames) - Check Lighting?`);
                }

                detectedGesture = 'none';
                document.getElementById('detectedEmoji').textContent = 'âœ‹';
                document.getElementById('detectedName').textContent = 'æœªæ£€æµ‹åˆ°æ‰‹';
            }

            handCtx.restore();

            // æ›´æ–°å’Œç»˜åˆ¶ç²’å­
            updateParticles();
            drawParticles();
        }

        // åˆå§‹åŒ– MediaPipe Hands
        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });

        hands.setOptions({
            maxNumHands: 2, // æ”¯æŒåŒæ‰‹
            modelComplexity: 1, // æé«˜ç²¾åº¦
            minDetectionConfidence: 0.5, // é™ä½é˜ˆå€¼ä»¥æé«˜çµæ•åº¦
            minTrackingConfidence: 0.5
        });

        hands.onResults(processHandResults);

        // åˆå§‹åŒ– MediaPipe Face Mesh for mask
        const faceMesh = new FaceMesh({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
            }
        });

        faceMesh.setOptions({
            maxNumFaces: 1,
            refineLandmarks: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        faceMesh.onResults((results) => {
            faceResults = results;
        });

        // Draw face mask overlay with streak effects
        let goldParticles = []; // For falling gold effect
        let maskType = Math.floor(Math.random() * 4); // 0: Pixel, 1: Square, 2: Round, 3: Aviator

        function drawFaceMask() {
            if (!faceResults || !faceResults.multiFaceLandmarks || faceResults.multiFaceLandmarks.length === 0) {
                return;
            }

            const landmarks = faceResults.multiFaceLandmarks[0];
            const w = handCanvas.width;
            const h = handCanvas.height;

            handCtx.save();
            handCtx.scale(-1, 1);
            handCtx.translate(-w, 0);

            const leftEye = landmarks[33];
            const rightEye = landmarks[263];
            const nose = landmarks[1];
            const forehead = landmarks[10];
            const chin = landmarks[152];
            const leftMouth = landmarks[61];
            const rightMouth = landmarks[291];

            const lx = leftEye.x * w;
            const ly = leftEye.y * h;
            const rx = rightEye.x * w;
            const ry = rightEye.y * h;
            const nx = nose.x * w;
            const ny = nose.y * h;
            const fx = forehead.x * w;
            const fy = forehead.y * h;

            const eyeDist = Math.abs(rx - lx);
            const faceWidth = eyeDist * 2.5;

            // Apply effect based on faceEffect state
            switch (faceEffect) {
                case 'glow':
                    // Crown effect (Win 3+)
                    handCtx.font = `${eyeDist * 1.5}px Arial`;
                    handCtx.fillText('ğŸ‘‘', (lx + rx) / 2 - eyeDist * 0.75, fy - eyeDist * 0.3);
                    // Sparkles around
                    handCtx.font = '20px Arial';
                    for (let i = 0; i < 5; i++) {
                        const angle = (Date.now() / 500 + i * 1.2) % (Math.PI * 2);
                        const sparkX = (lx + rx) / 2 + Math.cos(angle) * faceWidth * 0.6;
                        const sparkY = fy - eyeDist * 0.5 + Math.sin(angle) * 20;
                        handCtx.fillText('âœ¨', sparkX, sparkY);
                    }
                    drawCoolGlasses(lx, ly, rx, ry, fx, fy, eyeDist);
                    break;

                case 'car':
                    // Falling gold effect (Win 5+)
                    // Add new gold particles
                    if (Math.random() < 0.3) {
                        goldParticles.push({
                            x: Math.random() * w,
                            y: -30,
                            vy: 3 + Math.random() * 3,
                            size: 20 + Math.random() * 20,
                            emoji: ['ğŸ’°', 'ğŸª™', 'ğŸ’', 'â­'][Math.floor(Math.random() * 4)]
                        });
                    }
                    // Draw and update gold particles
                    handCtx.font = '30px Arial';
                    for (let i = goldParticles.length - 1; i >= 0; i--) {
                        const p = goldParticles[i];
                        handCtx.font = `${p.size}px Arial`;
                        handCtx.fillText(p.emoji, p.x, p.y);
                        p.y += p.vy;
                        if (p.y > h + 50) goldParticles.splice(i, 1);
                    }
                    // Crown on head
                    handCtx.font = `${eyeDist * 2}px Arial`;
                    handCtx.fillText('ğŸ‘‘', (lx + rx) / 2 - eyeDist, fy - eyeDist * 0.5);
                    drawCoolGlasses(lx, ly, rx, ry, fx, fy, eyeDist);
                    break;

                case 'sweat':
                    // Sweat drops + worried eyes (Lose 2)
                    handCtx.fillStyle = '#87CEEB';
                    for (let i = 0; i < 4; i++) {
                        const dropX = fx + (i - 1.5) * 25;
                        const dropY = fy + 15 + Math.sin(Date.now() / 150 + i) * 8;
                        handCtx.beginPath();
                        handCtx.ellipse(dropX, dropY, 6, 10, 0, 0, Math.PI * 2);
                        handCtx.fill();
                    }
                    // Worried expression
                    handCtx.font = `${eyeDist * 0.8}px Arial`;
                    handCtx.fillText('ğŸ˜°', nx - eyeDist * 0.4, ny + eyeDist);
                    drawCoolGlasses(lx, ly, rx, ry, fx, fy, eyeDist, 'worried');
                    break;

                case 'red':
                    // Red face + angry expression (Lose 3)
                    handCtx.beginPath();
                    handCtx.ellipse(nx, ny, faceWidth * 0.6, faceWidth * 0.7, 0, 0, Math.PI * 2);
                    handCtx.fillStyle = 'rgba(255, 50, 50, 0.3)';
                    handCtx.fill();
                    // Angry veins
                    handCtx.font = '30px Arial';
                    handCtx.fillText('ğŸ’¢', fx + eyeDist, fy);
                    drawCoolGlasses(lx, ly, rx, ry, fx, fy, eyeDist, 'angry');
                    break;

                case 'cyan':
                    // Cyan/frozen face (Lose 5)
                    handCtx.beginPath();
                    handCtx.ellipse(nx, ny, faceWidth * 0.6, faceWidth * 0.7, 0, 0, Math.PI * 2);
                    handCtx.fillStyle = 'rgba(100, 200, 255, 0.4)';
                    handCtx.fill();
                    // Frozen crystals
                    handCtx.font = '25px Arial';
                    handCtx.fillText('â„ï¸', lx - 20, ly);
                    handCtx.fillText('â„ï¸', rx + 10, ry);
                    handCtx.fillText('ğŸ¥¶', nx - eyeDist * 0.3, ny + eyeDist);
                    drawCoolGlasses(lx, ly, rx, ry, fx, fy, eyeDist, 'sad');
                    break;

                default:
                    // Normal cute mask
                    drawCoolGlasses(lx, ly, rx, ry, fx, fy, eyeDist, 'happy');
                    break;
            }

            handCtx.restore();
        }

        // Draw cool sunglasses with various expressions
        function drawCoolGlasses(lx, ly, rx, ry, fx, fy, eyeDist, expression = 'happy') {
            const glassW = eyeDist * 1.2;
            const glassH = glassW * 0.6;
            const glassY = (ly + ry) / 2;

            handCtx.fillStyle = '#000';
            handCtx.strokeStyle = '#000';
            handCtx.lineWidth = 3;

            // Draw different sunglasses styles based on maskType
            const style = maskType % 4; // 0: Pixel, 1: Square, 2: Round, 3: Aviator

            if (style === 0) {
                // Pixel / Deal With It Shades
                const pxSize = glassW / 6;
                const drawPixelLens = (x) => {
                    for (let i = 0; i < 6; i++) {
                        for (let j = 0; j < 3; j++) {
                            if (j === 0 || (j === 1 && i < 5) || (j === 2 && i < 4)) {
                                handCtx.fillRect(x - glassW / 2 + i * pxSize, glassY - glassH / 2 + j * pxSize, pxSize, pxSize);
                            }
                        }
                    }
                };
                drawPixelLens(lx);
                drawPixelLens(rx);
                // Bridge
                handCtx.fillRect((lx + rx) / 2 - pxSize, glassY - glassH / 2, pxSize * 2, pxSize);
            } else if (style === 1) {
                // Classic Square
                const cornerRad = 5;
                const drawSquareLens = (x) => {
                    handCtx.beginPath();
                    handCtx.roundRect(x - glassW / 2, glassY - glassH / 2, glassW, glassH, cornerRad);
                    handCtx.fill();
                };
                drawSquareLens(lx);
                drawSquareLens(rx);
                // Bridge
                handCtx.beginPath();
                handCtx.moveTo(lx + glassW / 2, glassY - glassH * 0.2);
                handCtx.quadraticCurveTo((lx + rx) / 2, glassY - glassH * 0.4, rx - glassW / 2, glassY - glassH * 0.2);
                handCtx.stroke();
            } else if (style === 2) {
                // Retro Round
                const drawRoundLens = (x) => {
                    handCtx.beginPath();
                    handCtx.arc(x, glassY, glassW / 1.8, 0, Math.PI * 2);
                    handCtx.fill();
                };
                drawRoundLens(lx);
                drawRoundLens(rx);
                // Bridge
                handCtx.beginPath();
                handCtx.arc((lx + rx) / 2, glassY - glassH * 0.1, eyeDist * 0.2, Math.PI, 0);
                handCtx.stroke();
            } else {
                // Aviator
                const drawAviatorLens = (x, isLeft) => {
                    handCtx.beginPath();
                    if (isLeft) {
                        handCtx.ellipse(x, glassY, glassW / 1.8, glassH / 1.5, 0.2, 0, Math.PI * 2);
                    } else {
                        handCtx.ellipse(x, glassY, glassW / 1.8, glassH / 1.5, -0.2, 0, Math.PI * 2);
                    }
                    handCtx.fill();
                };
                drawAviatorLens(lx, true);
                drawAviatorLens(rx, false);
                // Double Bridge
                handCtx.beginPath();
                handCtx.moveTo(lx + glassW / 4, glassY - glassH / 3);
                handCtx.lineTo(rx - glassW / 4, glassY - glassH / 3);
                handCtx.moveTo(lx + glassW / 4, glassY - glassH / 1.5);
                handCtx.lineTo(rx - glassW / 4, glassY - glassH / 1.5);
                handCtx.stroke();
            }

            // Reflection line on glasses
            handCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            handCtx.lineWidth = 4;
            handCtx.beginPath();
            handCtx.moveTo(lx - glassW / 3, glassY - glassH / 3);
            handCtx.lineTo(lx - glassW / 6, glassY - glassH / 6);
            handCtx.moveTo(rx - glassW / 3, glassY - glassH / 3);
            handCtx.lineTo(rx - glassW / 6, glassY - glassH / 6);
            handCtx.stroke();

            // Handle eyes/expressions on the lens
            const eyeSize = eyeDist * 0.2;
            handCtx.fillStyle = '#FFF';
            handCtx.strokeStyle = '#FFF';
            handCtx.lineWidth = 2;

            switch (expression) {
                case 'happy':
                    // Sparkles on lens
                    handCtx.font = `${eyeDist * 0.4}px Arial`;
                    handCtx.fillText('âœ¨', lx - eyeDist * 0.2, glassY);
                    handCtx.fillText('âœ¨', rx - eyeDist * 0.2, glassY);
                    break;
                case 'worried':
                    // Squinting white lines
                    handCtx.beginPath();
                    handCtx.moveTo(lx - eyeSize, glassY); handCtx.lineTo(lx + eyeSize, glassY);
                    handCtx.moveTo(rx - eyeSize, glassY); handCtx.lineTo(rx + eyeSize, glassY);
                    handCtx.stroke();
                    break;
                case 'angry':
                    // Angry white dots
                    handCtx.beginPath();
                    handCtx.arc(lx, glassY, eyeSize / 2, 0, Math.PI * 2);
                    handCtx.arc(rx, glassY, eyeSize / 2, 0, Math.PI * 2);
                    handCtx.fill();
                    // Eyebrows above glasses
                    handCtx.strokeStyle = '#000';
                    handCtx.lineWidth = 4;
                    handCtx.beginPath();
                    handCtx.moveTo(lx - eyeDist / 2, glassY - glassH);
                    handCtx.lineTo(lx + eyeDist / 4, glassY - glassH * 0.7);
                    handCtx.moveTo(rx + eyeDist / 2, glassY - glassH);
                    handCtx.lineTo(rx - eyeDist / 4, glassY - glassH * 0.7);
                    handCtx.stroke();
                    break;
                case 'sad':
                    // Teardrop falling from glass
                    handCtx.fillStyle = '#87CEEB';
                    handCtx.beginPath();
                    handCtx.ellipse(lx, glassY + glassH / 2 + 10, 5, 8, 0, 0, Math.PI * 2);
                    handCtx.fill();
                    break;
            }

            // Pink blush cheeks below glasses
            handCtx.fillStyle = 'rgba(255, 100, 150, 0.4)';
            handCtx.beginPath();
            handCtx.ellipse(lx - eyeDist * 0.3, glassY + glassH * 0.8, eyeDist * 0.2, eyeDist * 0.12, 0, 0, Math.PI * 2);
            handCtx.fill();
            handCtx.beginPath();
            handCtx.ellipse(rx + eyeDist * 0.3, glassY + glassH * 0.8, eyeDist * 0.2, eyeDist * 0.12, 0, 0, Math.PI * 2);
            handCtx.fill();
        }


        // Draw environmental effects (Rain, Thunder, Darkness)
        function drawWeather() {
            const w = handCanvas.width;
            const h = handCanvas.height;

            // 1. Rain (Lose 3+)
            if (isRainy) {
                if (rainParticles.length < 150) {
                    rainParticles.push({
                        x: Math.random() * w,
                        y: -50,
                        len: 15 + Math.random() * 15,
                        vy: 20 + Math.random() * 10
                    });
                }

                handCtx.save();
                handCtx.strokeStyle = 'rgba(170, 190, 255, 0.4)';
                handCtx.lineWidth = 1.5;
                for (let i = rainParticles.length - 1; i >= 0; i--) {
                    const r = rainParticles[i];
                    handCtx.beginPath();
                    handCtx.moveTo(r.x, r.y);
                    handCtx.lineTo(r.x, r.y + r.len);
                    handCtx.stroke();
                    r.y += r.vy;
                    if (r.y > h + 50) rainParticles.splice(i, 1);
                }
                handCtx.restore();
            }

            // 2. Thunder (Lose 5+)
            if (thunderIntensity > 0) {
                if (Math.random() < 0.015) { // Random lightning flash
                    handCtx.save();
                    handCtx.fillStyle = 'rgba(255, 255, 255, 0.45)';
                    handCtx.fillRect(0, 0, w, h);

                    // Draw a quick jagged line for lightning (optional but cool)
                    handCtx.strokeStyle = 'white';
                    handCtx.lineWidth = 5;
                    handCtx.beginPath();
                    let lx = Math.random() * w;
                    handCtx.moveTo(lx, 0);
                    for (let i = 1; i < 5; i++) {
                        lx += (Math.random() - 0.5) * 100;
                        handCtx.lineTo(lx, i * h / 5);
                    }
                    handCtx.stroke();
                    handCtx.restore();
                }
            }

            // 3. Darkness (Lose 7+)
            if (darkness > 0) {
                handCtx.save();
                // If game over, make it completely black, otherwise semi-transparent
                const finalDarkness = isGameOver ? 1.0 : darkness * 0.5;
                handCtx.fillStyle = `rgba(0,0,0, ${finalDarkness})`;
                handCtx.fillRect(0, 0, w, h);
                handCtx.restore();
            }
        }

        // Handle Game Over
        function checkGameOver() {
            if (isGameOver) {
                debugLog("GAME OVER TRIGGERED");

                // ä¿å­˜è®°å½•
                saveGameRecord(totalPoints);

                const overlay = document.createElement('div');
                overlay.id = 'gameOverOverlay';
                overlay.style.cssText = "position:fixed;top:0;left:0;width:100%;height:100%;background:black;display:flex;flex-direction:column;justify-content:center;align-items:center;z-index:10001;color:white;font-family:Arial, sans-serif;text-align:center;animation: fadeIn 2s ease-out;";
                overlay.innerHTML = `
                    <h1 style="font-size:80px;color:#ff4466;text-shadow: 0 0 20px rgba(255,68,102,0.5);margin:0;">GAME OVER</h1>
                    <p style="font-size:32px;margin:20px 0;">ä½ å·²è¢«é»‘æš—åå™¬...</p>
                    <p style="font-size:24px;color:#aaa;margin-bottom:40px;">æœ€åå¾—åˆ†: ${totalPoints}</p>
                    <button onclick="location.reload()" style="padding:20px 50px;font-size:24px;background:#00ff88;color:#000;border:none;border-radius:50px;cursor:pointer;font-weight:bold;box-shadow: 0 0 30px rgba(0,255,136,0.3);transition:transform 0.2s;">é‡æ–°æŒ‘æˆ˜</button>
                    <div style="margin-top:20px; color:#ffd700; font-size:18px; cursor:pointer;" onclick="document.getElementById('openLeaderboard').click(); document.getElementById('gameOverOverlay').style.display='none';">æŸ¥çœ‹æˆç»©</div>
                `;
                document.body.appendChild(overlay);

                // Add simple fade animation
                const style = document.createElement('style');
                style.innerHTML = `
                    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
                `;
                document.head.appendChild(style);
            }
        }

        // --- æ’è¡Œæ¦œé€»è¾‘ ---
        const STORAGE_KEY = 'rps_high_scores';

        function saveGameRecord(score) {
            if (score <= 0) return;
            let scores = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
            const newRecord = {
                score: score,
                date: new Date().toLocaleString(),
                id: Date.now()
            };
            scores.push(newRecord);
            // åªä¿ç•™å‰50å
            scores.sort((a, b) => b.score - a.score);
            scores = scores.slice(0, 50);
            localStorage.setItem(STORAGE_KEY, JSON.stringify(scores));
            updateLeaderboardUI();
        }

        function updateLeaderboardUI() {
            const listEl = document.getElementById('rankList');
            const scores = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');

            if (scores.length === 0) {
                listEl.innerHTML = '<div style="text-align:center; padding: 20px; color: #888;">æš‚æ— è®°å½•</div>';
                return;
            }

            listEl.innerHTML = scores.map((item, index) => `
                <div class="rank-item" style="animation: slideIn 0.3s ease forwards ${index * 0.05}s">
                    <div class="rank-info">
                        <div class="rank-pos">${index + 1}</div>
                        <div class="rank-score-details">
                            <div class="rank-score">${item.score}</div>
                            <div class="rank-date">${item.date}</div>
                        </div>
                    </div>
                    <div>${index === 0 ? 'ğŸ‘‘' : ''}</div>
                </div>
            `).join('');
        }

        // äº‹ä»¶ç»‘å®š
        document.getElementById('openLeaderboard').addEventListener('click', () => {
            updateLeaderboardUI();
            document.getElementById('leaderboardPanel').classList.add('show');
        });

        document.getElementById('closeLeaderboard').addEventListener('click', () => {
            document.getElementById('leaderboardPanel').classList.remove('show');
        });

        // åˆå§‹åŒ–æ‘„åƒå¤´
        async function initCamera() {
            try {
                const camera = new Camera(cameraElement, {
                    onFrame: async () => {
                        await hands.send({ image: cameraElement });
                        await faceMesh.send({ image: cameraElement });
                        drawFaceMask(); // Draw mask overlay
                        drawWeather(); // Draw environmental effects
                    },
                    width: 1280,
                    height: 720
                });
                await camera.start();
                loadingElement.classList.add('hidden');
            } catch (error) {
                console.error('æ‘„åƒå¤´åˆå§‹åŒ–å¤±è´¥:', error);
                loadingElement.innerHTML = `
                    <p style="color: #ff4466; font-size: 24px;">âš ï¸ æ— æ³•è®¿é—®æ‘„åƒå¤´</p>
                    <p style="margin-top: 10px;">è¯·ç¡®ä¿å·²æˆäºˆæ‘„åƒå¤´æƒé™</p>
                `;
                throw new Error("Camera initialization failed."); // Re-throw to stop game init
            }
        }

        // DEBUG LOGGER
        function debugLog(msg) {
            console.log(msg);
            let d = document.getElementById('debug-console');
            if (!d) {
                d = document.createElement('div');
                d.id = 'debug-console';
                d.style.cssText = "position:fixed;top:0;right:0;width:300px;height:200px;overflow:auto;background:rgba(0,0,0,0.5);color:lime;font-size:12px;z-index:9999;pointer-events:none;";
                document.body.appendChild(d);
            }
            d.innerHTML = `<div>${new Date().toLocaleTimeString()} ${msg}</div>` + d.innerHTML;
        }

        // ç»‘å®šäº‹ä»¶
        startBtn.addEventListener('click', () => {
            debugLog("Start Button Clicked");
            startRound().catch(e => {
                debugLog("ERROR in startRound: " + e.message);
                alert("Game Error: " + e.message);
                gameState = 'idle';
                startBtn.disabled = false;
            });
        });

        // åŠ¨ç”»å¾ªç¯
        function animate() {
            // Particles
            updateParticles();
            drawParticles();
            requestAnimationFrame(animate);
        }

        // åˆå§‹åŒ–
        async function initGame() {
            try {
                debugLog("--------------------------");
                debugLog("Step 1: Init Camera...");
                await initCamera();
                debugLog("Step 2: Camera DONE. Init UI...");

                try {
                    updateBattleUI(1);
                    debugLog("Step 3: UI DONE.");
                } catch (uiErr) {
                    debugLog("CRITICAL UI ERROR: " + uiErr.message);
                    console.error(uiErr);
                }

                debugLog("Step 4: Starting Animate Loop...");
                animate();
                debugLog("Step 5: ALL SYSTEMS GO. READY.");
                debugLog("--------------------------");
            } catch (err) {
                console.error("Game Init Failed:", err);
                debugLog("INIT FATAL ERROR: " + err.message);
                document.body.innerHTML += `<div style="position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);color:red;background:black;padding:20px;z-index:9999">Game Error: ${err.message}</div>`;
            }
        }

        let emptyHandCount = 0;
        // Modified processHandResults to log detection status
        const originalProcess = processHandResults;
        // We override the listener below


        initGame();
    </script>
</body>

</html>